<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    <title>Box on Grid</title>

    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>

</head>
<body>
  <div id="stage"></div>
  <script src="js/three.min.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/DeviceOrientationControls.js"></script>
  <script>
  (function() {
    'use strict';

    var scene;
    var box;
    var light;
    var ambient;
    var camera;
    var gridHelper;
    var renderer;
    var controls;
    var width = window.innerWidth;
    var height = window.innerHeight;

    //scene
    scene = new THREE.Scene();

    //box
    box = new THREE.Mesh(
        new THREE.BoxGeometry(40, 40, 40),
        new THREE.MeshLambertMaterial({ color: 0xff0000 })
    );
    box.position.set(0, 20, 0);
    scene.add(box);


    //light
    light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(0, 100, 30);
    scene.add(light);
    ambient = new THREE.AmbientLight(0x404040);
    scene.add(ambient);

    //camera
    camera = new THREE.PerspectiveCamera(100, width / height, 1, 5000);
    camera.position.set(0, 100, 300);
    camera.lookAt(scene.position);

    //helper
    gridHelper = new THREE.GridHelper(500, 50, 0xff0000);
    scene.add(gridHelper);

    //renderer
    renderer = new THREE.WebGLRenderer({ antialias: true});
    renderer.setSize(width, height);
    renderer.setClearColor(0x000000);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('stage').appendChild(renderer.domElement);

    function tick() {

      requestAnimationFrame(tick);

      //ï¿½ï¿½xï¿½Aï¿½Rï¿½ï¿½ï¿½gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½[ï¿½ÌXï¿½Vï¿½ï¿½ï¿½ï¿½ÄAï¿½lï¿½ğ”½‰fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
      if(controls) {
        controls.update();

        //ï¿½Xï¿½Vï¿½ï¿½Aï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½pï¿½xï¿½ï¿½fï¿½ï¿½ï¿½Ì‰ï¿½]ï¿½É—^ï¿½ï¿½ï¿½ï¿½iinverse = ï¿½tï¿½É‚ï¿½ï¿½Ä‚ï¿½ï¿½Ü‚ï¿½ï¿½B inverseï¿½iï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½j
        box.quaternion.copy(camera.quaternion.inverse());

        //LookAtï¿½Åƒï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Iï¿½ÉŒï¿½ï¿½ï¿½pï¿½x(ï¿½ï¿½ï¿½ï¿½ï¿½Ê’u)ï¿½É•Ï‚ï¿½ï¿½ï¿½
        camera.lookAt(0, 1, 0);
        //ï¿½dï¿½vï¿½ImatrixAutoUpdateï¿½ï¿½Ø‚ï¿½Ascene.updateï¿½@ï¿½ÅXï¿½Vï¿½ï¿½ï¿½ï¿½È‚ï¿½ï¿½æ‚¤ï¿½É‚ï¿½ï¿½ï¿½I
        camera.matrixAutoUpdate = false;

       renderer.render(scene, camera);

      } else {

        renderer.render(scene, camera);
        controls = new THREE.DeviceOrientationControls(camera);
        camera.updateProjectionMatrix();

      }
    }

    tick();

  })();
  </script>
</body>
</html>